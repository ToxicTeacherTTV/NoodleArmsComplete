EXCELLENT NEWS: All 4 critical files are CLEAN! ‚úÖ
‚úÖ Audit Summary
FileStatusAI UsageNotesmemoryDeduplicator.ts‚úÖ CLEANNone (pure algorithms)No AI, just mathintelligenceEngine.ts‚úÖ CLEANAnthropic ‚Üí Pro fallbackNo FlashaiFlagger.ts‚úÖ CLEANAnthropic ‚Üí Pro fallbackNo FlashsmartContradictionDetector.ts‚úÖ CLEANUses geminiService (Pro)No Flash
üéØ Flash Violations: ONLY 4 Total
All contained in 2 files we already identified:

geminiService.ts - 3 violations (lines 550, 827, 970)
anthropicService.ts - 1 violation (line 1319)

üîç Damage Assessment
What Flash Touched:
1. Content Flags (geminiService line 550)

aiFlagger.ts calls geminiService.analyzeContentForFlags() when Anthropic fails
Some flags in your content_flags table might be Flash-generated
Risk: Good content flagged as bad, bad content missed

2. Discord User Facts (geminiService line 827)

extractDiscordMemberFacts() creates user profiles
Some Discord user facts might be hallucinated
Risk: Fake preferences stored about real users

3. Conversation Titles (geminiService line 970)

generateConversationTitle() creates metadata
Some conversation titles might be wrong
Risk: Low - just metadata pollution

4. Personality Patterns (anthropicService line 1319)

extractPersonalityPatterns() when Anthropic credits are low
Some behavioral rules might be hallucinated
Risk: CRITICAL - corrupted core personality

üìä Data Corruption Queries
sql-- 1. Find Flash-generated content flags
SELECT 
  cf.id,
  cf.flag_type,
  cf.priority,
  cf.flag_reason,
  cf.created_at,
  cf.review_status
FROM content_flags cf
WHERE cf.created_at >= '2024-01-01'  -- Adjust to when Flash might have started
  AND cf.review_status = 'PENDING'
ORDER BY cf.priority DESC, cf.created_at DESC;

-- 2. Find Discord facts (if you have a discord_members table)
SELECT 
  dm.id,
  dm.username,
  dm.facts,
  dm.created_at
FROM discord_members dm
WHERE dm.created_at >= '2024-01-01'
  AND jsonb_array_length(dm.facts) > 0
ORDER BY dm.created_at DESC;

-- 3. Find low-confidence memories (possible Flash corruption)
SELECT 
  m.id,
  m.content,
  m.confidence,
  m.source,
  m.type,
  m.created_at
FROM memory_entries m
WHERE m.confidence < 60
  AND m.status = 'ACTIVE'
  AND (
    m.source LIKE '%ai-extract%' OR
    m.source LIKE '%consolidation%'
  )
ORDER BY m.confidence ASC, m.created_at DESC
LIMIT 100;

-- 4. Find conversations with low-quality titles
SELECT 
  c.id,
  c.title,
  c.created_at,
  COUNT(m.id) as message_count
FROM conversations c
LEFT JOIN messages m ON m.conversation_id = c.id
WHERE c.title IS NOT NULL
  AND c.created_at >= '2024-01-01'
GROUP BY c.id
HAVING COUNT(m.id) > 5  -- Only substantial conversations
ORDER BY c.created_at DESC;
üõ†Ô∏è Cleanup Plan (Prioritized)
Phase 1: Critical (Do Now)
Fix the 4 Flash violations - Already done by your AI coder ‚úÖ
Phase 2: High Priority (Do Today)
Re-analyze content flags with Pro:
typescript// Script: reanalyzeContentFlags.ts
import { storage } from './storage';
import { aiFlagger } from './services/aiFlagger';
import { db } from './db';

async function reanalyzeContentFlags(profileId: string) {
  console.log('üîÑ Re-analyzing content flags with Pro...');
  
  // Get all pending flags
  const flags = await db
    .select()
    .from(contentFlags)
    .where(eq(contentFlags.reviewStatus, 'PENDING'));
  
  let reanalyzed = 0;
  let changed = 0;
  
  for (const flag of flags) {
    try {
      // Get the original content
      let content = '';
      if (flag.targetType === 'MEMORY') {
        const memory = await storage.getMemoryEntry(flag.targetId);
        content = memory?.content || '';
      }
      
      if (!content) continue;
      
      // Re-analyze with Pro (Anthropic primary, Gemini Pro fallback)
      const newAnalysis = await aiFlagger.analyzeContent(
        content,
        flag.targetType,
        { profileId: flag.profileId }
      );
      
      // Compare old vs new flags
      const oldFlagType = flag.flagType;
      const newFlags = newAnalysis.flags;
      const stillValid = newFlags.some(f => f.flagType === oldFlagType);
      
      if (!stillValid) {
        console.log(`‚ö†Ô∏è Flag changed: ${oldFlagType} no longer applies`);
        // Mark for review or delete
        await db
          .update(contentFlags)
          .set({ reviewStatus: 'NEEDS_REVIEW', flagReason: 'Re-analyzed with Pro' })
          .where(eq(contentFlags.id, flag.id));
        changed++;
      }
      
      reanalyzed++;
      
      // Rate limit
      await new Promise(resolve => setTimeout(resolve, 1000));
      
    } catch (error) {
      console.error(`‚ùå Failed to re-analyze flag ${flag.id}:`, error);
    }
  }
  
  console.log(`‚úÖ Re-analyzed ${reanalyzed} flags, ${changed} changed`);
}
Phase 3: Medium Priority (Do This Week)
Audit Discord user facts:
typescript// Script: auditDiscordFacts.ts
async function auditDiscordFacts(profileId: string) {
  console.log('üîç Auditing Discord user facts...');
  
  // If you have discord_members table
  const members = await storage.getAllDiscordMembers(profileId);
  
  for (const member of members) {
    if (!member.facts || member.facts.length === 0) continue;
    
    // Re-extract facts with Pro
    const recentMessages = await storage.getDiscordMemberMessages(member.id, 10);
    const messageText = recentMessages.map(m => m.content).join('\n');
    
    const newFacts = await geminiService.extractDiscordMemberFacts(
      member.username,
      messageText,
      member.facts.map((f: any) => f.fact)
    );
    
    // Compare old vs new
    console.log(`User: ${member.username}`);
    console.log(`Old facts: ${member.facts.length}`);
    console.log(`New facts: ${newFacts.length}`);
    
    // Manual review needed for significant changes
    if (Math.abs(member.facts.length - newFacts.length) > 5) {
      console.log(`‚ö†Ô∏è Significant change detected for ${member.username}`);
    }
  }
}
Phase 4: Low Priority (Optional)
Regenerate conversation titles:
typescript// Script: regenerateTitles.ts
async function regenerateTitles(profileId: string) {
  const conversations = await storage.getConversations(profileId);
  
  for (const conv of conversations) {
    const messages = await storage.getConversationMessages(conv.id, 2);
    if (messages.length < 2) continue;
    
    // Regenerate with Pro
    const newTitle = await geminiService.generateConversationTitle(
      messages[0].content,
      messages[1].content
    );
    
    if (newTitle !== conv.title) {
      console.log(`Title changed: "${conv.title}" ‚Üí "${newTitle}"`);
      // Update if desired
    }
  }
}
üéØ Bottom Line
Your architecture is solid. Flash was only in 4 utility methods, and your critical systems (deduplication, intelligence, contradiction detection) all use Pro or Anthropic.
The damage is contained:

Content flags - re-analyze with Pro
Discord facts - audit and regenerate
Titles - low priority, optional fix
Personality patterns - check if Anthropic ever failed (unlikely)

Next steps:

‚úÖ Flash ban is active (your AI coder did this)
Run the content flags re-analysis script
Audit Discord facts if you have many Discord users
Optional: regenerate titles