
import { z } from 'zod';

export interface ValidationIssues {
  hasInvalidAccent: boolean;
  hasInvalidEmotion: boolean;
  hasDoubleBrackets: boolean;
  hasMetadataLeakage: boolean;
  hasStageDirections: boolean;
  hasMarkdownFormatting: boolean;
  details: string[];
}

export interface ValidationResult {
  isValid: boolean;
  score: number;
  status: 'VALID' | 'FIXABLE' | 'QUARANTINE';
  issues: ValidationIssues;
}

// ALLOWLISTS
// Allowed emotion tags (from runtime tag generation in chatService.normalizeResponseTags)
// MUST stay in sync with tags generated by normalizeResponseTags function
const ALLOWED_EMOTIONS = [
  'neutral',  // ← Runtime default
  'happy',
  'sad',
  'angry',
  'annoyed',
  'excited',
  'frustrated',
  'confused',
  'scared',
  'disgusted',
  'surprised',
  'sarcastic',
  'amused',
  'bored',
  'tired'
];

// Allowed action/delivery tags (from runtime tag generation in chatService.normalizeResponseTags)
const ALLOWED_ACTIONS = [
  'talking',  // ← Runtime default
  'yelling',
  'whispering',
  'sighing',
  'laughing',
  'chuckling',
  'muttering',
  'grumbling',
  'screaming',
  'rambling',
  'ranting',
  'scoffing',
  'nervous rambling',
  'manic',
  'deadpan',
  'rapid-fire'  // Allow creative AI tags
];

const ALLOWED_ACCENTS = [
  '[thick italian-italian american nyc accent]',
  '[strong bronx wiseguy accent]' // Legacy, map to canonical
];

  'furious', 'annoyed', 'grumpy', 'exasperated', 'unhinged', 'manic',
  'psycho', 'losing it', 'conspiratorial', 'suspicious', 'paranoid',
  'seething', 'disgusted', 'outraged', 'bitter', 'warm', 'genuine',
  'nostalgic', 'wistful', 'confused', 'shocked', 'appalled', 'weary',
  'exhausted', 'smug', 'arrogant', 'intense', 'defensive', 'incredulous'
];

export class TrainingDataValidator {

  public validate(content: string): ValidationResult {
    const issues: ValidationIssues = {
      hasInvalidAccent: false,
      hasInvalidEmotion: false,
      hasDoubleBrackets: false,
      hasMetadataLeakage: false,
      hasStageDirections: false,
      hasMarkdownFormatting: false,
      details: []
    };

    let score = 100;

    // 1. Check for Metadata Leakage (Critical)
    if (content.match(/\[Mode:.*\]/i) || content.match(/Quality Score:/i)) {
      issues.hasMetadataLeakage = true;
      issues.details.push("Contains metadata leakage (e.g., [Mode: PODCAST])");
      score -= 50;
    }

    // 2. Check for Double Brackets (Minor)
    if (content.match(/\[\[.*?\]\]/)) {
      issues.hasDoubleBrackets = true;
      issues.details.push("Contains double brackets [[...]]");
      score -= 10;
    }

    // 2b. Check for Markdown Formatting (Asterisks/Underscores for emphasis)
    // We look for *text* or _text_ patterns, but ignore if it's just a stray char (rare)
    if (content.match(/(\*|_)[^\s].*?(\*|_)/)) {
        issues.hasMarkdownFormatting = true;
        issues.details.push("Contains markdown formatting (*asterisks* or _underscores_)");
        score -= 5;
    }

    // 3. Extract Tags
    const tagMatches = content.match(/\[(.*?)\]/g);
    
    if (!tagMatches || tagMatches.length === 0) {
      issues.details.push("No tags found");
      score -= 100;
      return { isValid: false, status: 'QUARANTINE', score, issues };
    }

    // 4. Validate First Tag (Accent)
    const firstTag = tagMatches[0].toLowerCase();
    // Runtime uses "thick italian-italian american nyc accent", accept both forms
    const isCanonicalAccent = firstTag === '[thick italian-italian american nyc accent]' || 
                                firstTag === '[strong bronx wiseguy accent]';
    const isAllowedAccent = isCanonicalAccent || 
                            firstTag.includes('bronx') || 
                            firstTag.includes('italian') || 
                            firstTag.includes('nyc');

    if (!isAllowedAccent) {
      issues.hasInvalidAccent = true;
      issues.details.push(`Invalid accent tag: ${firstTag}`);
      score -= 20;
    } else if (firstTag !== '[thick italian-italian american nyc accent]' && 
               firstTag !== '[strong bronx wiseguy accent]') {
      issues.details.push(`Non-canonical accent tag: ${firstTag} (Fixable)`);
      score -= 5;
    }

    // 5. Validate Subsequent Tags (Actions / Emotions)
    for (let i = 1; i < tagMatches.length; i++) {
        const tagContent = tagMatches[i].replace(/[\[\]]/g, '').toLowerCase().trim();
        
        // 5a. Check for Complex Descriptors (Narrative Bloom)
        const isComplex = tagContent.includes(' with ') || 
                          tagContent.includes('running') || 
                          tagContent.split(' ').length > 3;

        if (isComplex) {
            issues.hasStageDirections = true; // Treat complex descriptions like stage directions
            issues.details.push(`Complex narrative tag found: [${tagContent}]`);
            score -= 50;
        }

        // 5b. Allowlist Check
        const isAction = ALLOWED_ACTIONS.includes(tagContent);
        const isEmotion = ALLOWED_EMOTIONS.includes(tagContent);

        if (!isAction && !isEmotion) {
             // If it's not strictly allowed, flag it (unless it's just a combo we missed, but strict is safer)
             issues.hasInvalidEmotion = true;
             issues.details.push(`Unknown tag: [${tagContent}]`);
             score -= 10;
        }
    }

    // 6. Check for Stage Directions (Critical Quarantine)
    // Look for verbs often used in roleplay narration
    const narrativeVerbs = [
      'dives', 'diving', 'jumps', 'jumping', 'walks', 'walking', 'runs', 'running', 
      'backs', 'backing', 'leans', 'leaning', 'gestures', 'gesturing', 'points', 'pointing', 
      'looks', 'looking', 'stares', 'staring', 'wipes', 'wiping', 'grabs', 'grabbing',
      'throws', 'throwing', 'picks', 'picking', 'turns', 'turning', 'shoves', 'shoving',
      'freezes', 'freezing', 'pauses', 'pausing'
    ];

    const bracketContents = tagMatches.map(t => t.slice(1, -1).toLowerCase());
    
    // Check if any tag content looks like a sentence or contains narrative verbs
    for (const tagContent of bracketContents) {
      // Skip known accent/emotion tags
      if (tagContent.includes('bronx')) continue;
      if (ALLOWED_EMOTIONS.some(e => tagContent.includes(e))) continue;

      const words = tagContent.split(/\s+/);
      const hasNarrativeVerb = words.some(w => narrativeVerbs.includes(w));
      const isLong = tagContent.length > 50;
      const hasPunctuation = /[.:]/.test(tagContent); // Narratives often have periods

      if (hasNarrativeVerb || (isLong && hasPunctuation)) {
        issues.hasStageDirections = true;
        issues.details.push(`Detected stage direction: [${tagContent}]`);
        score = 0; // Immediate disqualification
        break;
      }
    }

    // Determine Status
    let status: 'VALID' | 'FIXABLE' | 'QUARANTINE' = 'VALID';

    if (issues.hasStageDirections) {
      status = 'QUARANTINE';
    } else if (issues.hasMetadataLeakage || issues.hasDoubleBrackets || issues.hasInvalidAccent || issues.hasInvalidEmotion) {
      status = 'FIXABLE';
    }

    return {
      isValid: status === 'VALID',
      status,
      score: Math.max(0, score),
      issues
    };
  }
}

export const trainingDataValidator = new TrainingDataValidator();
