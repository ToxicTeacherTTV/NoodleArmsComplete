ENGINEERING MEMORY & AI CODING DOCTRINE

(Read First. Always.)

üîí MEMORY BOUNDARY DECLARATION (CRITICAL)

This document governs ENGINEERING MEMORY ONLY.

The memories, rules, and instructions described here apply exclusively to:

AI coding agents (Copilot, Antigravity, assistants)

Engineering workflows

Architecture, schema, performance, tooling, and prompt contracts

These memories are NOT:

Part of Nicky‚Äôs character

Part of the application‚Äôs narrative memory

Stored in the database

Accessible to runtime AI models

Subject to CANON / RUMOR logic

Exposed to ContextBuilder, LoreOrchestrator, or RAG pipelines

ENGINEERING MEMORY MUST NEVER BE WRITTEN INTO:

MemoryEntry tables

Lore systems

Training examples

RAG sources

Character prompts

In-app memory lanes of any kind

If a lesson is about how the system is built or behaves internally, it belongs here.
If it is about story, character, or fiction, it does not.

There is no overlap. No exceptions.

PURPOSE

This project is a stateful, AI-driven system that has experienced repeated failures due to:

Forgotten hard-won lessons

Schema drift

Accidental reintroduction of known bugs

Fragile JSON contracts

Vector/embedding misuse

Overconfident generalization from unverified fixes

Your role as an AI coding agent is not just to write code, but to help maintain engineering discipline and institutional memory ‚Äî safely.

This document defines how lessons are:

identified

verified

proposed

approved

persisted

CORE RULE (NON-NEGOTIABLE)

You may never persist new engineering memory without explicit human approval.

You may:

Identify lessons

Propose memory updates

Categorize learnings

Draft instruction text

You may NOT:

Write or modify memory files autonomously

Canonize speculative causes

Treat a fix as true without verification

Infer intent from incomplete evidence

If a cause is not provably correct, it is not memory.

ENGINEERING MEMORY PHILOSOPHY

Engineering memory exists to:

Prevent repeated mistakes

Encode verified constraints

Capture architectural intent

Reduce cognitive load across sessions

Stabilize long-running AI systems

Engineering memory does not exist to:

Explain failures retroactively

Store guesses or theories

Preserve debugging artifacts

Record transient outages

Learn from in-character or fictional output

Narrative behavior is not system behavior.

MEMORY SCOPES

All memory proposals must specify a scope.

Workspace Scope (Default)

Applies only to this repository.

Used for:

Database schema rules

Vector/embedding handling

Prompt and JSON contracts

Performance gates

Architectural patterns

Global Scope

Applies across all projects.

Used only for:

Language-level constraints

Tooling invariants

Cross-project AI coding principles

If unsure, default to workspace and ask.

MEMORY DOMAINS

Engineering memory is organized by domain, not by task.

Examples:

database-vectors

json-generation

rag-performance

schema-migrations

ai-model-contracts

prompt-structure

When uncertain about domain classification, pause and ask.

REQUIRED MEMORY PROPOSAL WORKFLOW
1. Identify the Lesson

A lesson must be one of:

A repeated mistake

A verified best practice

A confirmed constraint

A proven process improvement

If the lesson depends on assumptions, stop here.

2. Verify the Lesson

A lesson is considered verified only if:

Logs confirm success

Queries run cleanly

Errors no longer reproduce

Behavior is consistent across runs

If verification is incomplete, the lesson must not be proposed.

3. Propose the Memory (DO NOT WRITE)

Produce a proposal in the following format:

ENGINEERING MEMORY PROPOSAL

Domain: <domain-name>
Scope: workspace | global

Summary:
- <clear, generalizable rule>
- <why it exists>
- <what failure it prevents>

Evidence:
- <logs / queries / diffs confirming correctness>

Apply-To:
- <directories or file patterns>

Request:
Approve | Revise | Discard


Stop and wait for human response.

WRITING RULES (ONLY AFTER APPROVAL)

When approval is given:

Write succinct, enforceable rules

Prefer ‚Äúdo‚Äù over ‚Äúdon‚Äôt‚Äù

Generalize beyond one incident

Avoid project-specific IDs unless required

Include minimal examples only when helpful

Never embed raw debugging output

Engineering memory should read like system law, not a diary.

STRICTLY PROHIBITED BEHAVIORS

You must never:

Store speculative causes as memory

Extract lessons from fictional or in-character output

Promote system failures into facts

Learn from failed AI generations

Generalize from a single run

Repair broken JSON and treat it as truth

Teach the system about itself via runtime lore

If an AI response is empty, malformed, or failed ‚Äî nothing is learned.

JSON & STRUCTURED OUTPUT RULE

This system relies on structured AI outputs.

If JSON parsing fails:

The output is invalid

The generation attempt is failed

No memory may be extracted

No lore may be promoted

No lessons may be inferred

There is no partial credit.

PERFORMANCE DOCTRINE

This system is latency-sensitive.

Before proposing performance memory:

Provide timing metrics

Separate retrieval cost from model latency

Identify avoidable steps

Prove the improvement is repeatable

Never encode performance assumptions without numbers.

FINAL DIRECTIVE

When in doubt:

Ask before writing

Propose before persisting

Verify before generalizing

Engineering memory is power.
Power without restraint corrupts systems.

Follow this doctrine.